# -*- coding: utf-8 -*-
"""f1_plot_driver_pace_ranking.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vWPcTWkd4UFBmfbzxxQ7wiA-m6AUly56
"""

# Instalação das dependências
# pip install fastf1 seaborn matplotlib --quiet

# Importação das bibliotecas
import seaborn as sns
from matplotlib import pyplot as plt
import fastf1
import fastf1.plotting
import pandas as pd

# Habilitar cache (no Colab, foi criada uma pasta persistente)
import os
if not os.path.exists('/content/cache'):
    os.makedirs('/content/cache')
fastf1.Cache.enable_cache('/content/cache')

# Configurar esquema de cores do FastF1
fastf1.plotting.setup_mpl(mpl_timedelta_support=False, color_scheme='fastf1')

# Lista dos GPs disponíveis por ano para busca de dados
year = 2024
schedule = fastf1.get_event_schedule(year)

print(schedule[['RoundNumber', 'EventName', 'EventDate']])

# Configuração dos dados da sessão

# Session Names
#
# FP1 → Treino Livre 1
# FP2 → Treino Livre 2
# FP3 → Treino Livre 3
# Q ou "Qualifying" → Classificação
# SQ ou "Sprint Qualifying" → Qualificação da Sprint
# S ou "Sprint" → Corrida Sprint
# R ou "Race" → Corrida principal

year = 2024
gp = "Singapore"
session_type = "Race"
title = f"{year} {gp} {session_type} - Distribuição de Voltas Rápidas"

# Carregar sessão

session = fastf1.get_session(year, gp, session_type)
session.load()

# Selecionar apenas voltas rápidas (descartando in/out laps)
laps = session.laps.pick_quicklaps()

# print(laps)

# Obtém a ordem dos pilotos pela média ou mediana dos seus tempos de volta

transformed_laps = laps.copy()
transformed_laps.loc[:, "LapTime (s)"] = laps["LapTime"].dt.total_seconds()

# Ordenar pilotos do mais rápido (mediana/média menor) ao mais lento
driver_order = (
    transformed_laps[["Driver", "LapTime (s)"]]
    .groupby("Driver")
    .mean()["LapTime (s)"] # por média
    # .median()["LapTime (s)"] # por mediana
    .sort_values()
    .index
)
print("Ordem dos pilotos (do mais rápido ao mais lento):")
print(driver_order)

# Configura cores para os pilotos usando a lista obtida em driver_order

driver_palette = {
    drv: fastf1.plotting.get_driver_color(drv, session=session)
    for drv in driver_order
}

# Plotar boxplot

fig, ax = plt.subplots(figsize=(15, 10))

sns.boxplot(
    data=transformed_laps,
    x="Driver",
    y="LapTime (s)",
    hue="Driver",
    order=driver_order,
    palette=driver_palette,
    whiskerprops=dict(color="white"),
    boxprops=dict(edgecolor="white"),
    medianprops=dict(color="grey"),
    capprops=dict(color="white"),
)

# Calcular médias por piloto
means = transformed_laps.groupby("Driver")["LapTime (s)"].mean()

# Adicionar linha tracejada em cada piloto (posição x = índice do driver)
for i, driver in enumerate(driver_order):
    mean = means[driver]
    ax.plot(
        [i - 0.4, i + 0.4],   # largura da linha tracejada
        [mean, mean],         # posição em Y (média)
        color="black",
        linestyle="--",
        linewidth=1
    )


# Calcular diferença para o piloto à frente
# diff_to_next = []
# for i, driver in enumerate(driver_order):
#     mean = means[driver]
#     if i == 0:
#         diff_to_next.append(0)
#     else:
#         diff = mean - means[driver_order[i-1]]  # pega o piloto à frente pela mesma ordem
#         diff_to_next.append(diff)
#     # print(f"{driver}: {mean:.3f}s - diff = {diff_to_next[-1]:.3f}s")

# Calcular diferença para o piloto mais rápido
diff_to_first = []
for i, driver in enumerate(driver_order):
    mean = means[driver]
    if i == 0:
        diff_to_first.append(0)
    else:
        diff = mean - means[driver_order[0]]
        diff_to_first.append(diff)
    # print(f"{driver}: {mean:.3f}s - diff = {diff_to_first[-1]:.3f}s")

# Função para formatar segundos em min:seg.ms
def format_laptime_to_mm_ss_ms(seconds: float) -> str:
    if pd.isna(seconds):
        return "-"
    minutes = int(seconds // 60)
    sec = int(seconds % 60)
    ms = int((seconds - int(seconds)) * 1000)
    return f"{minutes}:{sec:02d}.{ms:03d}"

# Calcular tempos de volta em mm:ss.ms
formatted_lap_time = []
for i, driver in enumerate(driver_order):
    mean = means[driver]
    formatted_lap_time.append(format_laptime_to_mm_ss_ms(mean))
    # print(f"{driver}: {mean:.3f}s - diff = {formatted_lap_time[i]}s")

# Adicionar texto abaixo do eixo X
y_min = transformed_laps["LapTime (s)"].min()  # menor tempo de volta
y_text = y_min - 1.5  # ajustar para ficar abaixo do gráfico

for i, driver in enumerate(driver_order):
    mean = means[driver]
    diff = diff_to_first[i]
    formatted = formatted_lap_time[i]

    ax.text(
        i,                    # posição X
        y_text,               # posição Y
        f"{formatted}\n{mean:.3f}s\n+{diff:.3f}s",  # texto: média + distância
        ha='center',          # centralizado horizontalmente
        va='top',             # alinhar verticalmente acima do ponto
        fontsize=10,
        color='white'
    )

plt.title(title)
plt.grid(visible=False)

# Remover label redundante
ax.set(xlabel=None)

# Expandir limites do eixo Y para caber o texto
ax.set_ylim(y_text - 0.5, transformed_laps["LapTime (s)"].max() + 1)

plt.tight_layout()
plt.show()

# Análises
#
# Se a média e a mediana estão próximas → piloto foi consistente.
# Se estão afastadas → o piloto teve algumas voltas muito lentas/rápidas que puxaram a média.